/*==================================================================*/
/**
  @file usb_audio_class_20.c

  USB Audio Class 2.0 specification implementation

  @file         usb_audio_class_20.c
 
  @brief       Class specific descriptor generation
  
  @details    USB Audio Class 2.0 specification implementation

                 Copyright (c) 2017 Qualcomm Technologies Inc.
                 All Rights Reserved.
                 Qualcomm Confidential and Proprietary
*/
/*==================================================================*/

/*------------------------------------------------------------------------------------------
 * Include Files
 * ----------------------------------------------------------------------------------------*/
#include <stringl/stringl.h>

#include "usb_api.h"
#include "usb_log.h"
#include "usb_common.h"
#include "usb_dcd.h"
#include "usb_util.h"
#include "usb_fd.h"
#include "usb_audio_fd.h"
#include "usb_audio_class_20.h"


/*------------------------------------------------------------------------------------------
 * Preprocessor Definitions and Constants
 * ----------------------------------------------------------------------------------------*/
#define UAC20_FEEDBACK_EP_INTERVAL_US             (1000)
  
#define UAC20_AS_DATA_EP_ATTR_MAXPACKETONLY_POS   (7)
#define UAC20_AS_DATA_EP_LOCK_DELAY_UNIT_UNDEF    (0)
#define UAC20_AS_DATA_EP_LOCK_DELAY_UNIT_MS       (1)
#define UAC20_AS_DATA_EP_LOCK_DELAY_UNIT_PCM      (2)

// Reference: UAC2.0 - Section A.17.7 - Feature Unit Control Selectors
// bmaControls
#define UAC20_FU_MUTE_POS                         (0)
#define UAC20_FU_VOLUME_POS                       (2)

#define UAC20_CONTROL_NONE                        (0)
#define UAC20_CONTROL_READ_ONLY                   (1)
#define UAC20_CONTROL_INVALID                     (2)
#define UAC20_CONTROL_HOST_PGM                    (3)

// Clock Source - bmAttributes
#define UAC20_CS_ATTR_CT_POS                      (0)  // clock type attribute
#define UAC20_CS_ATTR_CT_EXTERNAL                 (0)
#define UAC20_CS_ATTR_CT_INTERNAL_FIXED           (1)
#define UAC20_CS_ATTR_CT_INTERNAL_VARIABLE        (2)
#define UAC20_CS_ATTR_CT_INTERNAL_PROGRAMMABLE    (3)
#define UAC20_CS_ATTR_CS_SOF_POS                  (2)  // clock sync to SOF attribute
#define UAC20_CS_ATTR_CS_NOT_SOF                  (0)
#define UAC20_CS_ATTR_CS_SOF                      (1)

// Clock Source - bmControls
#define UAC20_CS_BMC_CLK_FREQ_POS                 (0)  // clock frequency control
#define UAC20_CS_BMC_CLK_VALD_POS                 (2)  // clock validity control

// Clock source controls
#define UAC20_CSRC_CONTROL_NONE                   (0x00)
#define UAC20_CSRC_CONTROL_SAMPLING_FREQ          (0x01)
#define UAC20_CSRC_CONTROL_CLOCK_VALID            (0x02)

// Reference: UAC2.0 - 4.1 Audio Channel Cluster Descriptor 
// bmChannelConfig
#define UAC20_CH_CONFIG_FL_POS                    (0)   // front left
#define UAC20_CH_CONFIG_FR_POS                    (1)   // front right

// Input terminal bmChannelConfig
#define UAC20_CH_COFIG_MONO                       (0x0)
#define UAC20_CH_COFIG_STEREO                     ((1 << UAC20_CH_CONFIG_FL_POS) | (1 << UAC20_CH_CONFIG_FR_POS))

// Reference: UAC2.0 - 4.7.2.8 - Feature Unit Descriptor
// bmChannelConfig
#define UAC20_CONTROL_FU_MUTE_POS                 (0)
#define UAC20_CONTROL_FU_VOLUME_POS               (2)

// Feature unit bmaControls
#define UAC20_FU_CONTROL_NONE                     (0x0)
#define UAC20_FU_CONTROL_MUTE                     (UAC20_CONTROL_HOST_PGM << UAC20_FU_MUTE_POS)
#define UAC20_FU_CONTROL_VOLUME                   (UAC20_CONTROL_HOST_PGM << UAC20_FU_VOLUME_POS)

#define UAC20_FU_REQ_CONTROL_MUTE                 (0x1)
#define UAC20_FU_REQ_CONTROL_VOLUME               (0x2)

// Reference: UAC 2.0 Audio Data Format Document - Section A.1
// Format Type Codes
#define UAC20_FORMAT_TYPE_UNDEF                   (0)
#define UAC20_FORMAT_TYPE_1                       (1)

// Reference: UAC 2.0 Audio Data Format Document - Section A.2
// bmFormats
#define UAC20_BMF_TYPE1_PCM_POS                   (0)
#define UAC20_BMF_TYPE1_RAW_DATA_POS              (31)

// Reference: UAC 2.0 Section 5.2.2 Control Request Layout
#define UAC20_REQ_CUR                             (0x01)
#define UAC20_REQ_RANGE                           (0x02)


/*------------------------------------------------------------------------------------------
 * Type Declarations
 * ----------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------
 * Constants
 * ----------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------
 * Function Declarations and Definitions
 * ----------------------------------------------------------------------------------------*/
uint8* uac20_ac_handle_get_req(usb_audio_ctx_t* audio_ctx, uint8 ifc_num, uint8 unit_id, 
  uint8 ch, uint8 control, uint8 req, uint32* len)
{
  audio_node_t* node = NULL;
  (*len) = 0;

  node = usb_fn_fd_audio()->usb_audio_get_node(audio_ctx, unit_id);
  USB_ERR_HALT(node);

  if(node && node->val.type == AUDIO_FEATURE_UNIT)
  {
    switch(control)
    {
      case UAC20_FU_REQ_CONTROL_MUTE:
      {
        if(req == UAC20_REQ_CUR)
        {
          USB_ULOG_1(BAM_QLOG, "mute control GET_CURR, fu_id %d", unit_id);
          if(TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_MUTE, AUDIO_REQ_CURR, 
           (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
          {
             return audio_ctx->dsc_buff;
          }
        }
      }
      break;

      case UAC20_FU_REQ_CONTROL_VOLUME:
      {
        switch (req)
        {
          case UAC20_REQ_CUR:
          {
            USB_ULOG_1(BAM_QLOG, "volume control GET_CURR, fu_id %d", unit_id);
            if (TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_CURR, 
              (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
            {
              return audio_ctx->dsc_buff;
            }
          }
          break;

          case UAC20_REQ_RANGE:
          {
            USB_ULOG_1(BAM_QLOG, "volume control GET_RANGE, fu_id %d", unit_id);
            if(TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_RANGE, 
              (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
            {
              return audio_ctx->dsc_buff;
            }
          }
          break;
        }
      }
      break;

      default:
        USB_ULOG(BAM_QLOG, "unknown control");
    }
  }

  if(node && node->val.type == AUDIO_CLOCK_SOURCE)
  {
    switch(control)
    {
      case UAC20_CSRC_CONTROL_SAMPLING_FREQ:
      {
        switch(req)
        {
          case UAC20_REQ_CUR:
          {
            *len = sizeof(uint32);
            USB_ULOG_1(BAM_QLOG, "sampling freq GET_CURR, clock_id %d", unit_id);
          }
          return (uint8*) &node->cs.controls_ptr->freq;
 
          case UAC20_REQ_RANGE:
          {
            *len = node->cs.controls_ptr->range_size;
            USB_ULOG_1(BAM_QLOG, "sampling freq GET_RANGE, clock_id %d", unit_id);
          }
          return (uint8*) node->cs.controls_ptr->range;
        }
      }

      case UAC20_CSRC_CONTROL_CLOCK_VALID:
      {
        switch(req)
        {
          case UAC20_REQ_CUR:
          {
            (*len) = 1;
            USB_ULOG_1(BAM_QLOG, "clock valid GET_CURR, clock_id %d", unit_id);
          }
          return (uint8*) &node->cs.controls_ptr->valid;
        }
      }
    }
  }

  return NULL;
}

boolean uac20_ac_handle_set_req(usb_audio_ctx_t* audio_ctx, uint8 ifc_num, uint8 unit_id, 
  uint8 ch, uint8 control, uint8 req, uint32* buff, uint32 len)
{
  audio_node_t* node = NULL;

  node = usb_fn_fd_audio()->usb_audio_get_node(audio_ctx, unit_id);
  USB_ERR_HALT(node);

  if(node && node->val.type == AUDIO_FEATURE_UNIT)
  {
    switch(control)
    {
      case UAC20_FU_REQ_CONTROL_MUTE:
      {
        if(req == UAC20_REQ_CUR)
        {         
          USB_ULOG_1(BAM_QLOG, "mute control SET_CURR, fu_id %d", unit_id);
          return audio_ctx->set_req(ifc_num, node, AUDIO_CTRL_FU_MUTE, AUDIO_REQ_CURR, 
            (audio_ch_t)ch, buff, len);
        }
      }
      break;
    
      case UAC20_FU_REQ_CONTROL_VOLUME:
      {
        switch (req)
        {
          case UAC20_REQ_CUR:
            USB_ULOG_1(BAM_QLOG, "volume control SET_CURR, fu_id %d", unit_id);
            return audio_ctx->set_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_CURR, 
            (audio_ch_t)ch, buff, len);
        }
      }
      break;
    
      default:
        USB_ULOG(BAM_QLOG, "unknown control");
    }
  }

  if(node && node->val.type == AUDIO_CLOCK_SOURCE)
  {
    switch(control)
    {     
      case UAC20_CSRC_CONTROL_SAMPLING_FREQ:
      {
        switch(req)
        {
          case UAC20_REQ_CUR:
          USB_ULOG_1(BAM_QLOG, "sampling freq SET_CURR, clock_id %d", unit_id);
          node->cs.controls_ptr->freq = *((uint32*) buff);
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

uint8* uac20_as_handle_get_req(usb_audio_stream_t* stream, uint8 ifc_num, uint8 recp, 
  uint8 req, uint8 control, uint32* len)
{
  return NULL;
}

boolean uac20_as_handle_set_req(usb_audio_stream_t* stream, uint8 ifc_num, 
  uint8 recp, uint8 req, uint8 control, uint32* buff, uint32 len)
{
  return FALSE;
}

uint8 uac20_get_bps(usb_dcd_dsc_interface_t* ifc)
{
  uac2_as_ifc_type1_desc_t* as_ifc_type1;
  USB_ASSERT(ifc);
  as_ifc_type1 = (uac2_as_ifc_type1_desc_t*) ((uint8*)ifc->cs_dsc + sizeof(uac2_as_ifc_desc_t));
  return as_ifc_type1->bSubSlotSize;
}

uint16 uac20_alloc_as_cs_ep_desc(uint8** dsc, uint16* len, uint16 dsc_size)
{
  uac2_as_cs_data_ep_desc_t* as_cs_ep = (uac2_as_cs_data_ep_desc_t*) (*dsc);
  (*len) += sizeof(uac2_as_cs_data_ep_desc_t);
  USB_ASSERT(as_cs_ep && ((*len) < dsc_size));
  as_cs_ep->bLength             = sizeof(uac2_as_cs_data_ep_desc_t);    // 8 bytes
  as_cs_ep->bDescriptorType     = USB_AUDIO_CS_EP_DESC_TYPE;            // CS_ENDPOINT
  as_cs_ep->bDescriptorSubType  = USB_AUDIO_CS_EP_DESC_SUBTYPE_GENERAL; // EP_GENERAL
  as_cs_ep->bmAttributes        = 0;
  as_cs_ep->bmControls          = 0x00;
  as_cs_ep->bLockDelayUnits     = UAC20_AS_DATA_EP_LOCK_DELAY_UNIT_PCM;
  as_cs_ep->wLockDelay          = 0x00;  // Endpoint takes n samples to lock internal recovery clock.
  (*dsc) += sizeof(uac2_as_cs_data_ep_desc_t);
  return sizeof(uac2_as_cs_data_ep_desc_t);
}

uint16 uac20_alloc_as_ifc_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_audio_stream_t* stream, uint8 slot_size, uint8 bit_res)
{
  uac2_as_ifc_desc_t* as_ifc = (uac2_as_ifc_desc_t *)(*dsc);
  uac2_as_ifc_type1_desc_t* as_ifc_type1;
  uint32 cs_offset = (*len);

  // Allocate AudioStreaming Class-Specific descriptor
  (*len) += sizeof(uac2_as_ifc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  as_ifc->bLength             = sizeof(uac2_as_ifc_desc_t);             // 16 bytes
  as_ifc->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;                 // CS_INTERFACE
  as_ifc->bDescriptorSubType  = USB_AUDIO_CS_IFC_DESC_SUBTYPE_GENERAL;  // AS_GENERAL
  as_ifc->bTerminalLink       = stream->term->val.id;                   // Endpoint Terminal ID
  as_ifc->bmControls          = 0x00;
  as_ifc->bFormatType         = UAC20_FORMAT_TYPE_1;  
  as_ifc->bmFormats           = (1 << UAC20_BMF_TYPE1_PCM_POS);
  as_ifc->bNrChannels         = stream->cfg.n_ch;
  as_ifc->bmChannelConfig     = UAC20_CH_COFIG_MONO; //default
  as_ifc->iChannelNames       = 0x00;

  if (stream->cfg.n_ch == 2) // stereo
  {
    as_ifc->bmChannelConfig = UAC20_CH_COFIG_STEREO;
  }
  
  (*dsc) += sizeof(uac2_as_ifc_desc_t);

  // Allocate AudioStreaming format type-1 descriptor
  (*len) += sizeof(uac2_as_ifc_type1_desc_t);
  USB_ASSERT((*len) < dsc_size);
  as_ifc_type1 = (uac2_as_ifc_type1_desc_t*)(*dsc);
  as_ifc_type1->bLength             = sizeof(uac2_as_ifc_type1_desc_t);     // 6 bytes
  as_ifc_type1->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;               // CS_INTERFACE
  as_ifc_type1->bDescriptorSubType  = USB_AUDIO_CS_IFC_DESC_SUBTYPE_FORMAT; // FORMAT_TYPE
  as_ifc_type1->bFormatType         = UAC20_FORMAT_TYPE_1;
  as_ifc_type1->bSubSlotSize        = slot_size;
  as_ifc_type1->bBitResolution      = bit_res;
  (*dsc) += sizeof(uac2_as_ifc_type1_desc_t);

  return ((*len) - cs_offset);
}

usb_dcd_dsc_interface_t* uac20_alloc_as_desc(uint8** dsc, uint16* len, 
uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 n_ep;
  uint8 alt_set;
  uint8 slot_size;
  uint8 bit_res;
  uint8 i;
  uint8 j;
  usb_dcd_dsc_interface_t* ifc;
  usb_dcd_dsc_interface_t* ifc_itr;
  usb_dcd_dsc_endpoint_t* ep_itr;
  usb_dcd_dsc_endpoint_t* fb_ep_itr;
  uint8 ep_num = 0;
  uint8 bm1 = 0;
  uint8 ep_mask = 0;
  uint8 ep_attr = 0;
  uint16 max_packet_size = USB_AUDIO_MAX_TRANSFER_SIZE;
  boolean expl_fb_ep = FALSE;
  uint8 fb_ep_attr = 0;
  uint8 fb_ep_num = 0;
  uint8 fb_bm1 = 0;
  uint8 fb_size = 0;
  usb_audio_stream_t* stream = (usb_audio_stream_t* )data;

  USB_ASSERT(stream);

  switch(stream->ifc_id)
  {
    case USB_IFC_ID_AUDIO_STREAMING_MIC:
    {
      ep_num = ++(*ep_in_num);
      ep_mask = USB_EP_ADDR_IN;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;
    }
    break;

    case USB_IFC_ID_AUDIO_STREAMING_SPEAKER:
    {
      ep_num = ++(*ep_out_num);
      ep_mask = USB_EP_ADDR_OUT;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;

#ifdef USB_AUDIO_EXPL_ASYNC_FEEDBACK
      // Explicit ASYNC feedback endpoint
      expl_fb_ep = TRUE;
      fb_ep_num  = ++(*ep_in_num);
      fb_ep_num |= USB_EP_ADDR_IN;
      fb_ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_NONE | USB_EP_ATTR_USAGE_FEEDBACK;
      fb_size = (stream->speed == USB_FULL_SPEED) ? USB_AUDIO_FB_FREQ_SIZE_FS : USB_AUDIO_FB_FREQ_SIZE_HS;
#endif
    }
    break;

    default:
      USB_ERR_FATAL("Unknown stream type", stream->ifc_id, 0, 0);
  }


  // Allocate default interface alt_set(0).
  n_ep = 0;
  alt_set = 0;
  ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, USB_INTERFACE_CLASS_AUDIO, 
    USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, UAC_IFC_PROTOCOL_VERSION_02_00, 
      USB_INTERFACE_STR_INDEX_NONE);
  ifc->id = stream->ifc_id;
  ifc->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;

  fb_bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(UAC20_FEEDBACK_EP_INTERVAL_US, stream->usb_frame_us);

  // Allocate alt_set(n)
  for(i=0; i < stream->slot_arr_size; i++)
  {
    slot_size = stream->slot_arr[i].slot_size;
    bit_res = stream->slot_arr[i].bit_res;
    bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(stream->slot_arr[i].bint_us, stream->usb_frame_us);

    // Special Case : Burst Mode
    // In case data endpoint has higher bm1 use that for feedback endpoint.
    // Preserve saving realized through LPM by using higher service interval.
    if(bm1 > fb_bm1)
    {
      fb_bm1 = bm1;
    }

    alt_set = i+1;
    n_ep = expl_fb_ep ? 2 : 1;
    ifc_itr = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, USB_INTERFACE_CLASS_AUDIO, 
      USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, UAC_IFC_PROTOCOL_VERSION_02_00, 
      USB_INTERFACE_STR_INDEX_NONE);
    INSERT_TAIL(usb_dcd_dsc_interface, ifc, ifc_itr);
    ifc_itr->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;
    ifc_itr->id = stream->ifc_id;
    ifc_itr->cs_dsc = (*dsc);
    ifc_itr->cs_dsc_size = usb_fn_uac2()->uac20_alloc_as_ifc_desc(dsc, len, dsc_size, stream, slot_size, bit_res);

    for(j=stream->freq_arr_size; j; j--)
    {
      max_packet_size = usb_fn_fd_audio()->usb_audio_calc_transfer_size(stream->freq_arr[j-1], stream->cfg.n_ch,
        slot_size, bm1, stream->usb_frame_us);
      if(max_packet_size <= USB_AUDIO_MAX_TRANSFER_SIZE)
      {
        break;
      }
    }

    ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, ep_num, ep_mask, ep_attr, (bm1+1), max_packet_size);
    INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, ep_itr);
    ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_session;
    ep_itr->ifc = ifc_itr;
    ep_itr->cs_dsc = (*dsc);
    ep_itr->cs_dsc_size = usb_fn_uac2()->uac20_alloc_as_cs_ep_desc(dsc, len, dsc_size);

    // Allocate explicit ASYNC feedback endpoint descriptor
    if (expl_fb_ep)
    {
      fb_ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, fb_ep_num, USB_EP_ADDR_IN, fb_ep_attr,
        (fb_bm1+1), fb_size);
      INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, fb_ep_itr);
      fb_ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_expl_fb;
      fb_ep_itr->ifc = ifc_itr;
    }
  }

  return ifc;
}

void uac20_alloc_ac_ot_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_ot_t* aot,
  usb_audio_profile_t audio_profile)
{
  uac2_ac_ot_desc_t* ot = (uac2_ac_ot_desc_t*) (*dsc);
  (*len) += sizeof(uac2_ac_ot_desc_t);
  USB_ASSERT((*len) < dsc_size);
  ot->bLength             = sizeof(uac2_ac_ot_desc_t);    // 12 bytes
  ot->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  ot->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_OT; // OUTPUT_TERMINAL           
  ot->bTerminalID         = aot->id;
  ot->wTerminalType       = USB_AUDIO_TERM_TYPE_STREAMING;
  ot->bAssocTerminal      = 0x0;
  ot->bSourceID           = aot->source_id;
  ot->bCSourceID          = aot->clock_id;
  ot->bmControls          = 0x0;  
  ot->iTerminal           = 0x0;

  if(aot->term_type == AUDIO_TERMINAL_SPEAKER)
  {
    ot->wTerminalType = usb_fn_fd_audio()->usb_audio_get_ot_type(audio_profile);
  }

  (*dsc) += sizeof(uac2_ac_ot_desc_t);
}

void uac20_alloc_ac_mu_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_mu_t* amu)
{
  uac2_ac_mu_desc_t* mu = (uac2_ac_mu_desc_t*) (*dsc);
  (*len) += sizeof(uac2_ac_mu_desc_t);
  USB_ASSERT((*len) < dsc_size);
  mu->bLength             = sizeof(uac2_ac_mu_desc_t);    // 16 bytes
  mu->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  mu->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_MU; // MIXER_UNIT
  mu->bUnitID             = amu->id;
  mu->bNrInPins           = amu->n_sources;
  mu->baSourceID1         = amu->source_id[0];
  mu->baSourceID2         = amu->source_id[1];
  mu->bNrChannels         = amu->n_op_ch;                 // Number of output channels.
  mu->bmChannelConfig     = UAC20_CH_COFIG_MONO;          // Default
  mu->iChannelNames       = 0x00;
  mu->bmMixerControls     = 0x00;
  mu->bmControls          = 0x00;
  mu->iMixer              = 0x00;

  if(mu->bNrChannels == 2) // stereo
  {
    mu->bmChannelConfig = UAC20_CH_COFIG_STEREO;
  }

  (*dsc) += sizeof(uac2_ac_mu_desc_t);
}

void uac20_alloc_ac_fu_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_fu_t* afu)
{
  uint8* ac_dsc = (*dsc);
  uac2_ac_fu_desc_t* fu = (uac2_ac_fu_desc_t*) ac_dsc;
  uint8 i;
  uint8 bLength = sizeof(uac2_ac_fu_desc_t) + (afu->n_ch * sizeof(uint32)) + 1; // 9 bytes + (4 * n_ch) + 1 (iFeature)

  (*len) += bLength;
  USB_ASSERT((*len) < dsc_size);
  fu->bLength             = bLength;   
  fu->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  fu->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_FU; // FEATURE_UNIT
  fu->bUnitID             = afu->id;
  fu->bSourceID           = afu->source_id;
  fu->bmaControls0        = 0;
  ac_dsc += sizeof(uac2_ac_fu_desc_t);

  // Master channel contols
  if(afu->controls & AUDIO_CTRL_FU_MUTE)
  {
    fu->bmaControls0 |= UAC20_FU_CONTROL_MUTE;
  }

  if(afu->controls & AUDIO_CTRL_FU_VOLUME)
  {
    fu->bmaControls0 |= UAC20_FU_CONTROL_VOLUME;
  }

  // Populate controls for logical channels.
  // Advertise same controls as master channel on logical channels.
  // bmaControls(n)
  for(i=0; i < afu->n_ch; i++)
  {
    // compiler cannot resolve unaligned word writes.
    ac_dsc[0] = (fu->bmaControls0 & 0xFF);
    ac_dsc[1] = 0;
    ac_dsc[2] = 0;
    ac_dsc[3] = 0;
    ac_dsc += sizeof(uint32);
  }

  // Assign uint8 iFeature
  ac_dsc[0] = 0x0;
  ac_dsc++; //sizeof(uint8);

  (*dsc) = ac_dsc;
}

void uac20_alloc_ac_it_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_it_t* ait)
{
  uac2_ac_it_desc_t* it = (uac2_ac_it_desc_t*)(*dsc);

  (*len) += sizeof(uac2_ac_it_desc_t);
  USB_ASSERT((*len) < dsc_size);
  it->bLength             = sizeof(uac2_ac_it_desc_t);    // 17 bytes
  it->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  it->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_IT; // INPUT_TERMINAL           
  it->bTerminalID         = ait->id;
  it->wTerminalType       = USB_AUDIO_TERM_TYPE_STREAMING;
  it->bAssocTerminal      = 0x00;
  it->bCSourceID          = ait->clock_id;
  it->bNrChannels         = ait->n_ch;
  it->bmChannelConfig     = 0x00; // mono - default
  it->iChannelNames       = 0x00;
  it->bmControls          = 0x00;
  it->iTerminal           = 0x00;

  if(ait->term_type == AUDIO_TERMINAL_MIC)
  {
    it->wTerminalType = USB_AUDIO_TERM_TYPE_IT_MIC;
  }

  if(it->bNrChannels == 2)// stereo
  {
    it->bmChannelConfig = UAC20_CH_COFIG_STEREO;
  }
  
  (*dsc) += sizeof(uac2_ac_it_desc_t);
}

void uac20_alloc_ac_csel_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_ifc_id ifc_id, uint8 source_id, uint8 term_id)
{
  uac2_ac_csel_desc_t* csel = (uac2_ac_csel_desc_t*)(*dsc);
  (*len) += sizeof(uac2_ac_csel_desc_t);
  USB_ASSERT((*len) < dsc_size);
  csel->bLength             = sizeof(uac2_ac_csel_desc_t);    // 8 bytes
  csel->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;         // CS_INTERFACE
  csel->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_CSRC; // CLOCK_SOURCE
  csel->bClockID            = term_id;  // Terminal ID of clock
  csel->bNrPins             = 0x1;      // 0x1 - hard coded
  csel->baCSourceID         = source_id;
  csel->bmControls          = 0x0;
  csel->iClockSelector      = 0x0;
  (*dsc) += sizeof(uac2_ac_csel_desc_t);
}

void uac20_alloc_ac_csrc_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_cs_t* acs)
{
  uac2_ac_csrc_desc_t* csrc = (uac2_ac_csrc_desc_t*)(*dsc);
  (*len) += sizeof(uac2_ac_csrc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  csrc->bLength             = sizeof(uac2_ac_csrc_desc_t);    // 8 bytes
  csrc->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;         // CS_INTERFACE
  csrc->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_CSRC; // CLOCK_SOURCE
  csrc->bClockID            = acs->id;                         // Terminal ID of clock
  csrc->bmAttributes        = UAC20_CS_ATTR_CT_INTERNAL_PROGRAMMABLE << UAC20_CS_ATTR_CT_POS;
  csrc->bmControls          = 0x00;
  csrc->bAssocTerminal      = 0x00;
  csrc->iClockSource        = 0x00;

  if (acs->controls & AUDIO_CTRL_CS_FREQ)
  {
    csrc->bmControls |= (UAC20_CONTROL_HOST_PGM << UAC20_CS_BMC_CLK_FREQ_POS);
  }

  if (acs->controls & AUDIO_CTRL_CS_VALID)
  {
    csrc->bmControls |= (UAC20_CONTROL_READ_ONLY << UAC20_CS_BMC_CLK_VALD_POS);
  }

  (*dsc) += sizeof(uac2_ac_csrc_desc_t);
}

void uac20_alloc_ac_header_desc(uint8** dsc, uint16* len, uint16 dsc_size, uint8 n_as, uint8 ifc_idx)
{
  uac2_cs_ac_ifc_header_t* ac_header = (uac2_cs_ac_ifc_header_t *) (*dsc);
  (*len) += sizeof(uac2_cs_ac_ifc_header_t);
  USB_ASSERT((*len) < dsc_size);
  ac_header->bLength            = sizeof(uac2_cs_ac_ifc_header_t);  // 9 bytes
  ac_header->bDescriptorType    = USB_AUDIO_CS_DESC_TYPE;           // CS_INTERFACE
  ac_header->bDescriptorSubType = USB_AUDIO_CS_DESC_SUBTYPE_HEADER; // Header            
  ac_header->bcdADC             = USB_AUDIO_CLASS_REV_2;            // USB_AUDIO_CLASS_REV_2 
  ac_header->bCategory          = USB_AUDIO_FN_CATEGORY_HEADSET;    
  ac_header->wTotalLength       = sizeof(uac2_cs_ac_ifc_header_t);  // update at end
  ac_header->bmControls         = 0x00; 
  (*dsc) += sizeof(uac2_cs_ac_ifc_header_t);
}

void uac20_alloc_ac_ifc_asoc_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  uint8 ifc_num, uint8 n_ifc)
{
  uac_std_ifc_asoc_desc_t* ifc_asoc = (uac_std_ifc_asoc_desc_t*) (*dsc);
  (*len) += sizeof(uac_std_ifc_asoc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  ifc_asoc->bLength           = sizeof(uac_std_ifc_asoc_desc_t); // 8 bytes
  ifc_asoc->bDescriptorType   = USB_AUDIO_STD_IFC_ASOC_DESC_TYPE; // CS_INTERFACE
  ifc_asoc->bFirstInterface   = ifc_num;
  ifc_asoc->bInterfaceCount   = n_ifc;
  ifc_asoc->bFunctionClass    = USB_INTERFACE_CLASS_AUDIO;
  ifc_asoc->bFunctionSubClass = USB_INTERFACE_AUDIO_SUBCLASS_UNDEFINED;
  ifc_asoc->bFunctionProtocol = UAC_FN_PROTOCOL_VERSION_02_00;
  ifc_asoc->iFunction         = 0x00;
  (*dsc) += sizeof(uac_std_ifc_asoc_desc_t);
}

uint16 uac20_alloc_ac_cs_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_audio_ctx_t* audio_ctx, uint8 ifc_num)
{
  uint8 i;
  uac2_cs_ac_ifc_header_t* ac_header;
  uint32 uac_offset = (*len);

  // Allocate class speficic header
  ac_header = (uac2_cs_ac_ifc_header_t *) (*dsc);
  usb_fn_uac2()->uac20_alloc_ac_header_desc(dsc, len, dsc_size, audio_ctx->n_ifc, ifc_num);

  // Get number of audio streams registered with AudioControl interface.
  for(i = 0; i < audio_ctx->n_nodes; i++)
  {
    audio_node_t* node = &audio_ctx->topology[i];
    switch(node->val.type)
    {
      case AUDIO_CLOCK_SOURCE:
      {
        usb_fn_uac2()->uac20_alloc_ac_csrc_desc(dsc, len, dsc_size, (audio_cs_t*) node);
      }
      break;

      case AUDIO_INPUT_TERMINAL:
      {
        usb_fn_uac2()->uac20_alloc_ac_it_desc(dsc, len, dsc_size, (audio_it_t*) node);
      }
      break;

      case AUDIO_FEATURE_UNIT:
      {
        usb_fn_uac2()->uac20_alloc_ac_fu_desc(dsc, len, dsc_size, (audio_fu_t*) node);
      }
      break;

      case AUDIO_MIXER_UNIT:
      {
        usb_fn_uac2()->uac20_alloc_ac_mu_desc(dsc, len, dsc_size, (audio_mu_t*) node);
      }
      break;

      case AUDIO_OUTPUT_TERMINAL:
      {
        usb_fn_uac2()->uac20_alloc_ac_ot_desc(dsc, len, dsc_size, (audio_ot_t*)node, audio_ctx->profile);
      }
      break;

      default:
        USB_ULOG_1(DBG_E_QLOG, "unknwon node type %d", node->val.type);
        USB_LOG_ERR_1(log_uac20_alloc_ac_cs_desc__unknown_node_D, (uint32)node->val.type);
    }
  }

  ac_header->wTotalLength = (*len) - uac_offset;
  return ((*len) - uac_offset);
}

usb_dcd_dsc_interface_t* uac20_alloc_ac_desc(uint8 ** dsc, uint16 * len, 
  uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 alt_set = 0;
  uint8 n_ep = 0;
  usb_dcd_dsc_interface_t* ifc;
  usb_audio_ctx_t* audio_ctx = (usb_audio_ctx_t*) data;
  USB_ASSERT(audio_ctx);

  // Allocate interface association descriptor for AudioControl class collection
  usb_fn_uac2()->uac20_alloc_ac_ifc_asoc_desc(dsc, len, dsc_size, ifc_num, audio_ctx->n_ifc+1);

  ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
    USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_CONTROL, 
    UAC_IFC_PROTOCOL_VERSION_02_00, USB_INTERFACE_STR_INDEX_NONE);

  ifc->id = audio_ctx->id;
  ifc->cs_dsc = (*dsc);
  ifc->cs_dsc_size = usb_fn_uac2()->uac20_alloc_ac_cs_desc(dsc, len, dsc_size, audio_ctx, ifc_num);
  return ifc;
}

/*----------------------------------------------------------------------------
 * Function table definitions - UAC2.0 FD layer
 * -------------------------------------------------------------------------*/

usb_fn_tbl_uac2_t fn_tbl_uac2 = 
{
  uac20_ac_handle_get_req,
  uac20_ac_handle_set_req,
  uac20_as_handle_get_req,
  uac20_as_handle_set_req,
  uac20_get_bps,
  uac20_alloc_as_cs_ep_desc,
  uac20_alloc_as_ifc_desc,
  uac20_alloc_as_desc,
  uac20_alloc_ac_ot_desc,
  uac20_alloc_ac_mu_desc,
  uac20_alloc_ac_fu_desc,
  uac20_alloc_ac_it_desc,
  uac20_alloc_ac_csel_desc,
  uac20_alloc_ac_csrc_desc,
  uac20_alloc_ac_header_desc,
  uac20_alloc_ac_ifc_asoc_desc,
  uac20_alloc_ac_cs_desc,
  uac20_alloc_ac_desc,
};


