/*==================================================================*/
/**
  @file usb_audio_class_30.c

  USB Audio Class 3.0 specification implementation

  @file         usb_audio_class_30.c
 
  @brief       Class specific descriptor generation
  
  @details    USB Audio Class 3.0 specification implementation

                 Copyright (c) 2017 Qualcomm Technologies Inc.
                 All Rights Reserved.
                 Qualcomm Confidential and Proprietary
*/
/*==================================================================*/

/*------------------------------------------------------------------------------------------
 * Include Files
 * ----------------------------------------------------------------------------------------*/
#include <stringl/stringl.h>
#include "usb_api.h"
#include "usb_log.h"
#include "usb_common.h"
#include "usb_dcd.h"
#include "usb_util.h"
#include "usb_fd.h"
#include "usb_audio_fd.h"
#include "usb_audio_class_30.h"

/*------------------------------------------------------------------------------------------
 * Preprocessor Definitions and Constants
 * ----------------------------------------------------------------------------------------*/
#define UAC30_FEEDBACK_EP_INTERVAL_US             (1000)

#define UAC30_FN_PROTOCOL_VERSION_03_00           (0x30)
#define UAC30_IFC_PROTOCOL_VERSION_03_00          (0x30)
#define UAC30_IFC_DESC_SUBTYPE_VALID_FREQ_RANGE   (0x02)
#define UAC30_D1_TO_D0_RECOVERY_TIME_MS           (30)
#define UAC30_D2_TO_D0_RECOVERY_TIME_MS           (300)
 
#define UAC30_AS_DATA_EP_LOCK_DELAY_UNIT_UNDEF    (0)
#define UAC30_AS_DATA_EP_LOCK_DELAY_UNIT_MS       (1)
#define UAC30_AS_DATA_EP_LOCK_DELAY_UNIT_PCM      (2)

// Reference: UAC3.0 - Table 4-31.
// bmaControls
#define UAC30_FU_MUTE_POS                         (0)
#define UAC30_FU_VOLUME_POS                       (2)

#define UAC30_CONTROL_NONE                        (0)
#define UAC30_CONTROL_READ_ONLY                   (1)
#define UAC30_CONTROL_INVALID                     (2)  // this value is not allowed
#define UAC30_CONTROL_HOST_PGM                    (3)

// Clock Source - bmAttributes
#define UAC30_CS_ATTR_CT_POS                      (0)  // clock type attribute
#define UAC30_CS_ATTR_CT_EXTERNAL                 (0)
#define UAC30_CS_ATTR_CT_INTERNAL                 (1)

#define UAC30_CS_ATTR_ST_POS                      (2)  // clock synchronization type
#define UAC30_CS_ATTR_ST_ASYNC                    (0)
#define UAC30_CS_ATTR_ST_SYNC_SOF                 (1)

// Clock Source - bmControls
#define UAC30_CS_BMC_CLK_FREQ_POS                 (0)  // clock frequency control
#define UAC30_CS_BMC_CLK_VALD_POS                 (2)  // clock validity control

// Clock source controls
#define UAC30_CSRC_CONTROL_NONE                   (0x00)
#define UAC30_CSRC_CONTROL_SAMPLING_FREQ          (0x01)
#define UAC30_CSRC_CONTROL_CLOCK_VALID            (0x02)

// Reference: UAC3.0 - A.24 
// Table A-40 : Connector Types
#define UAC30_CONN_TYPE_3P5MM                     (0x02)
#define UAC30_CONN_ATTR_GENDER_POS                (0x0)
#define UAC30_CONN_ATTR_GENDER_FEMALE             (0x2)
#define UAC30_CONN_ATTR_INSERT_POS                (0x0)
#define UAC30_CONN_ATTR_INSERT_YES                (0x1)
#define UAC30_CONN_COLOR_UNSPECIFIED              (0x01000000)

// cluster ID
#define UAC30_CLUSTER_DESCR_MONO                  (0x1)
#define UAC30_CLUSTER_DESCR_STEREO                (0x2)
#define UAC30_CLUSTER_DESCR_SEG_CH_INF            (0x20)
#define UAC30_CLUSTER_DESCR_SEG_END               (0xFF)
#define UAC30_CLUSTER_DESCR_CHREL_MONO            (0x1)
#define UAC30_CLUSTER_DESCR_CHREL_LEFT            (0x2)
#define UAC30_CLUSTER_DESCR_CHREL_RIGHT           (0x3)

// Reference: UAC2.0 - 4.7.2.8 - Feature Unit Descriptor
// bmChannelConfig
#define UAC30_CONTROL_FU_MUTE_POS                 (0)
#define UAC30_CONTROL_FU_VOLUME_POS               (2)

// Feature unit bmaControls
#define UAC30_FU_CONTROL_NONE                     (0x0)
#define UAC30_FU_CONTROL_MUTE                     (UAC30_CONTROL_HOST_PGM << UAC30_FU_MUTE_POS)
#define UAC30_FU_CONTROL_VOLUME                   (UAC30_CONTROL_HOST_PGM << UAC30_FU_VOLUME_POS)

#define UAC30_FU_REQ_CONTROL_MUTE                 (0x1)
#define UAC30_FU_REQ_CONTROL_VOLUME               (0x2)

// Reference: UAC 3.0 Audio Data Format Document
// Table - A-2 : Audio data formats bit allocations.
// bmFormats
#define UAC30_BMF_TYPE1_PCM_POS                   (0)

// Reference: UAC 2.0 Section 5.2.2 Control Request Layout
#define UAC30_REQ_CUR                             (0x01)
#define UAC30_REQ_RANGE                           (0x02)

#define BADD3_SLOT_ARR_SIZE                       (2)

/*------------------------------------------------------------------------------------------
 * Type Declarations
 * ----------------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------------------
 * Constants
 * ----------------------------------------------------------------------------------------*/
static const uint32 badd3_freq = 48000;

static const audio_slot_size_t badd3_slot_arr[BADD3_SLOT_ARR_SIZE] = 
{
  {16, 2, 1000 },
  {24, 3, 1000 },  
};

/*------------------------------------------------------------------------------------------
 * Function Declarations and Definitions
 * ----------------------------------------------------------------------------------------*/
uint8* uac30_ac_handle_get_req(usb_audio_ctx_t* audio_ctx, uint8 ifc_num, uint8 unit_id, 
  uint8 ch, uint8 control, uint8 req, uint32* len)
{
  audio_node_t* node = NULL;

  node = usb_fn_fd_audio()->usb_audio_get_node(audio_ctx, unit_id);

  if(NULL == node)
  {
    (*len) = 0;
    return NULL;
  }

  if(node->val.type == AUDIO_FEATURE_UNIT)
  {
    switch(control)
    {
      case UAC30_FU_REQ_CONTROL_MUTE:
      {
        if(req == UAC30_REQ_CUR)
        {
          USB_ULOG_1(BAM_QLOG, "mute control GET_CURR, fu_id %d", unit_id);
          if(TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_MUTE, AUDIO_REQ_CURR, 
           (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
          {
             return audio_ctx->dsc_buff;
          }
        }
      }
      break;

      case UAC30_FU_REQ_CONTROL_VOLUME:
      {
        switch (req)
        {
          case UAC30_REQ_CUR:
          {
            USB_ULOG_1(BAM_QLOG, "volume control GET_CURR, fu_id %d", unit_id);
            if (TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_CURR, 
              (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
            {
              return audio_ctx->dsc_buff;
            }
          }
          break;

          case UAC30_REQ_RANGE:
          {
            USB_ULOG_1(BAM_QLOG, "volume control GET_RANGE, fu_id %d", unit_id);
            if(TRUE == audio_ctx->get_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_RANGE, 
              (audio_ch_t)ch, (uint32*)audio_ctx->dsc_buff, len))
            {
              return audio_ctx->dsc_buff;
            }
          }
          break;
        }
      }
      break;

      default:
        USB_ULOG(BAM_QLOG, "unknown control");
    }
  }

  if(node->val.type == AUDIO_CLOCK_SOURCE)
  {
    switch(control)
    {
      case UAC30_CSRC_CONTROL_SAMPLING_FREQ:
      {
        switch(req)
        {
          case UAC30_REQ_CUR:
          {
            *len = sizeof(uint32);
            USB_ULOG_1(BAM_QLOG, "sampling freq GET_CURR, clock_id %d", unit_id);
          }
          return (uint8*) &node->cs.controls_ptr->freq;
 
          case UAC30_REQ_RANGE:
          {
            *len = node->cs.controls_ptr->range_size;
            USB_ULOG_1(BAM_QLOG, "sampling freq GET_RANGE, clock_id %d", unit_id);
          }
          return (uint8*) node->cs.controls_ptr->range;
        }
      }

      case UAC30_CSRC_CONTROL_CLOCK_VALID:
      {
        switch(req)
        {
          case UAC30_REQ_CUR:
          {
            (*len) = 1;
            USB_ULOG_1(BAM_QLOG, "clock valid GET_CURR, clock_id %d", unit_id);
          }
          return (uint8*) &node->cs.controls_ptr->valid;
        }
      }
    }
  }

  return NULL;
}

boolean uac30_ac_handle_set_req(usb_audio_ctx_t* audio_ctx, uint8 ifc_num, uint8 unit_id, 
  uint8 ch, uint8 control, uint8 req, uint32* buff, uint32 len)
{
  audio_node_t* node = NULL;

  node = usb_fn_fd_audio()->usb_audio_get_node(audio_ctx, unit_id);
  USB_ERR_HALT(node);

  if(node && node->val.type == AUDIO_FEATURE_UNIT)
  {
    switch(control)
    {
      case UAC30_FU_REQ_CONTROL_MUTE:
      {
        if(req == UAC30_REQ_CUR)
        {         
          USB_ULOG_1(BAM_QLOG, "mute control SET_CURR, fu_id %d", unit_id);
          return audio_ctx->set_req(ifc_num, node, AUDIO_CTRL_FU_MUTE, AUDIO_REQ_CURR, 
            (audio_ch_t)ch, buff, len);
        }
      }
      break;
    
      case UAC30_FU_REQ_CONTROL_VOLUME:
      {
        switch (req)
        {
          case UAC30_REQ_CUR:
            USB_ULOG_1(BAM_QLOG, "volume control SET_CURR, fu_id %d", unit_id);
            return audio_ctx->set_req(ifc_num, node, AUDIO_CTRL_FU_VOLUME, AUDIO_REQ_CURR, 
            (audio_ch_t)ch, buff, len);
        }
      }
      break;
    
      default:
        USB_ULOG(BAM_QLOG, "unknown control");
    }
  }

  if(node && node->val.type == AUDIO_CLOCK_SOURCE)
  {
    switch(control)
    {     
      case UAC30_CSRC_CONTROL_SAMPLING_FREQ:
      {
        switch(req)
        {
          case UAC30_REQ_CUR:
          USB_ULOG_1(BAM_QLOG, "sampling freq SET_CURR, clock_id %d", unit_id);
          node->cs.controls_ptr->freq = *((uint32*) buff);
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

uint8* uac30_as_handle_get_req(usb_audio_stream_t* stream, uint8 ifc_num, uint8 recp, 
  uint8 req, uint8 control, uint32* len)
{
  return NULL;
}

boolean uac30_as_handle_set_req(usb_audio_stream_t* stream, uint8 ifc_num, 
  uint8 recp, uint8 req, uint8 control, uint32* buff, uint32 len)
{
  return FALSE;
}

uint8 badd3_get_bps(usb_dcd_dsc_interface_t* ifc)
{
  USB_ASSERT(ifc);
  return badd3_slot_arr[(ifc->descriptor->bAlternateSetting - 1)].slot_size;
}

#ifdef USB_ENABLE_UAC30_FLAG
uint8 uac30_get_bps(usb_dcd_dsc_interface_t* ifc)
{
  uac3_as_ifc_desc_t* as_ifc;;
  USB_ASSERT(ifc);
  as_ifc = (uac3_as_ifc_desc_t*) ifc->cs_dsc;
  return as_ifc->bSubSlotSize;
}

uint16 uac30_alloc_as_cs_ep_desc(uint8** dsc, uint16* len, uint16 dsc_size)
{
  uac3_as_cs_data_ep_desc_t* as_cs_ep = (uac3_as_cs_data_ep_desc_t*) (*dsc);
  (*len) += sizeof(uac3_as_cs_data_ep_desc_t);
  USB_ASSERT(as_cs_ep && ((*len) < dsc_size));
  as_cs_ep->bLength             = sizeof(uac3_as_cs_data_ep_desc_t);    // 10 bytes
  as_cs_ep->bDescriptorType     = USB_AUDIO_CS_EP_DESC_TYPE;            // CS_ENDPOINT
  as_cs_ep->bDescriptorSubType  = USB_AUDIO_CS_EP_DESC_SUBTYPE_GENERAL; // EP_GENERAL
  as_cs_ep->bmControls          = 0x00;
  as_cs_ep->bLockDelayUnits     = UAC30_AS_DATA_EP_LOCK_DELAY_UNIT_PCM;
  as_cs_ep->wLockDelay          = 0x00;  // Endpoint takes n samples to lock internal recovery clock.  
  (*dsc) += sizeof(uac3_as_cs_data_ep_desc_t);
  return sizeof(uac3_as_cs_data_ep_desc_t);
}

uint16 uac30_alloc_as_ifc_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_audio_stream_t* stream, uint8 slot_size, uint8 bit_res, uint8 bm1, uint16* max_packet_size)
{
  uac3_as_ifc_desc_t* as_ifc = (uac3_as_ifc_desc_t*)(*dsc);
  uac3_as_freq_range_desc_t* as_freq_range;
  uint32 cs_offset = (*len);
  uint8 i;
  uint16 packet_size;

  // Allocate AudioStreaming Class-Specific descriptor
  (*len) += sizeof(uac3_as_ifc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  as_ifc->bLength             = sizeof(uac3_as_ifc_desc_t);
  as_ifc->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;
  as_ifc->bDescriptorSubType  = USB_AUDIO_CS_IFC_DESC_SUBTYPE_GENERAL;
  as_ifc->bTerminalLink       = stream->term->val.id;
  as_ifc->bmControls          = 0x00;
  as_ifc->wClusterID          = stream->cfg.n_ch;
  as_ifc->bmFormats           = (1 << UAC30_BMF_TYPE1_PCM_POS);
  as_ifc->bSubSlotSize        = slot_size;
  as_ifc->bBitResolution      = bit_res;
  as_ifc->bmAuxProtocol       = 0x00;
  as_ifc->bControlSize        = 0x00; 
  (*dsc) += sizeof(uac3_as_ifc_desc_t);

  //Add a frequency range descriptor to explicitly advertise min and max frequency on this alternet setting.
  as_freq_range = (uac3_as_freq_range_desc_t*) (*dsc);
  (*len) += sizeof(uac3_as_freq_range_desc_t);
  USB_ASSERT((*len) < dsc_size);
  as_freq_range->bLength            = sizeof(uac3_as_freq_range_desc_t);
  as_freq_range->bDescriptorType    = USB_AUDIO_CS_DESC_TYPE;
  as_freq_range->bDescriptorSubType = UAC30_IFC_DESC_SUBTYPE_VALID_FREQ_RANGE;
  as_freq_range->dMin               = (~0);
  as_freq_range->dMax               = 0;

  for(i=0; i < stream->freq_arr_size; i++)
  {
    packet_size = usb_fn_fd_audio()->usb_audio_calc_transfer_size(stream->freq_arr[i], stream->cfg.n_ch,
      slot_size, bm1, stream->usb_frame_us);
    if(packet_size <= USB_AUDIO_MAX_TRANSFER_SIZE)
    {
      if(stream->freq_arr[i] < as_freq_range->dMin)
      {
        as_freq_range->dMin = stream->freq_arr[i];
      }

      if(stream->freq_arr[i] > as_freq_range->dMax)
      {
        *max_packet_size = packet_size;
        as_freq_range->dMax = stream->freq_arr[i];
      }
    }
  }
  (*dsc) += sizeof(uac3_as_freq_range_desc_t);
  return ((*len) - cs_offset);
}
#endif

usb_dcd_dsc_interface_t* badd3_alloc_as_desc(uint8** dsc, uint16* len, 
uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 n_ep;
  uint8 alt_set;
  uint8 slot_size;
  uint8 bit_res;
  uint8 i;
  usb_dcd_dsc_interface_t* ifc_itr;
  usb_dcd_dsc_endpoint_t* ep_itr;
  usb_dcd_dsc_endpoint_t* fb_ep_itr;
  uint8 ep_num = 0;
  uint8 bm1 = 0;
  uint8 ep_mask = 0;
  uint8 ep_attr = 0;
  uint16 max_packet_size = USB_AUDIO_MAX_TRANSFER_SIZE;
  boolean expl_fb_ep = FALSE;
  uint8 fb_ep_attr = 0;
  uint8 fb_ep_num = 0;
  uint8 fb_bm1 = 0;
  uint8 fb_size = 0;
  usb_audio_stream_t* stream = (usb_audio_stream_t* )data;

  USB_ASSERT(stream);

  switch(stream->ifc_id)
  {
    case USB_IFC_ID_AUDIO_STREAMING_MIC:
    {
      ep_num = ++(*ep_in_num);
      ep_mask = USB_EP_ADDR_IN;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;
    }
    break;

    case USB_IFC_ID_AUDIO_STREAMING_SPEAKER:
    {
      ep_num = ++(*ep_out_num);
      ep_mask = USB_EP_ADDR_OUT;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;

#ifdef USB_AUDIO_EXPL_ASYNC_FEEDBACK
      // Explicit ASYNC feedback endpoint
      expl_fb_ep = TRUE;
      fb_ep_num  = ++(*ep_in_num);
      fb_ep_num |= USB_EP_ADDR_IN;
      fb_ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_NONE | USB_EP_ATTR_USAGE_FEEDBACK;
      fb_size = (stream->speed == USB_FULL_SPEED) ? USB_AUDIO_FB_FREQ_SIZE_FS : USB_AUDIO_FB_FREQ_SIZE_HS;
#endif
    }
    break;

    default:
      USB_ERR_FATAL("Unknown stream type", stream->ifc_id, 0, 0);
  }


  // Allocate default interface alt_set(0).
  n_ep = 0;
  alt_set = 0;
  stream->ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
    USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, 
    UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);
  stream->ifc->id = stream->ifc_id;
  stream->ifc->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;

  fb_bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(UAC30_FEEDBACK_EP_INTERVAL_US, stream->usb_frame_us);

  // Allocate alt_set(n)
  for(i=0; i < BADD3_SLOT_ARR_SIZE; i++)
  {
    slot_size = badd3_slot_arr[i].slot_size;
    bit_res = badd3_slot_arr[i].bit_res;
    bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(badd3_slot_arr[i].bint_us, stream->usb_frame_us);

    // Special Case : Burst Mode
    // In case data endpoint has higher bm1 use that for feedback endpoint.
    // Preserve saving realized through LPM by using higher service interval.
    if(bm1 > fb_bm1)
    {
      fb_bm1 = bm1;
    }

    alt_set = i+1;
    n_ep = expl_fb_ep ? 2 : 1;
    ifc_itr = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
      USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, 
      UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);
    INSERT_TAIL(usb_dcd_dsc_interface, stream->ifc, ifc_itr);
    ifc_itr->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;
    ifc_itr->id = stream->ifc_id;
    ifc_itr->cs_dsc = NULL;
    ifc_itr->cs_dsc_size = 0;

    max_packet_size = usb_fn_fd_audio()->usb_audio_calc_transfer_size(badd3_freq, stream->cfg.n_ch,slot_size, bm1, 
      stream->usb_frame_us);

    ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, ep_num, ep_mask, ep_attr, (bm1+1), 
      max_packet_size);
    INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, ep_itr);
    ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_session;
    ep_itr->ifc = ifc_itr;
    ep_itr->cs_dsc = NULL;
    ep_itr->cs_dsc_size = NULL;

    // Allocate explicit ASYNC feedback endpoint descriptor
    if (expl_fb_ep)
    {
      fb_ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, fb_ep_num, USB_EP_ADDR_IN, fb_ep_attr,
        (fb_bm1+1), fb_size);
      INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, fb_ep_itr);
      fb_ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_expl_fb;
      fb_ep_itr->ifc = ifc_itr;
    }
  }

  return stream->ifc;
}

#ifdef USB_ENABLE_UAC30_FLAG
usb_dcd_dsc_interface_t* uac30_alloc_as_desc(uint8** dsc, uint16* len, 
uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 n_ep;
  uint8 alt_set;
  uint8 slot_size;
  uint8 bit_res;
  uint8 i;
  usb_dcd_dsc_interface_t* ifc;
  usb_dcd_dsc_interface_t* ifc_itr;
  usb_dcd_dsc_endpoint_t* ep_itr;
  usb_dcd_dsc_endpoint_t* fb_ep_itr;
  uint8 ep_num = 0;
  uint8 bm1 = 0;
  uint8 ep_mask = 0;
  uint8 ep_attr = 0;
  uint16 max_packet_size = USB_AUDIO_MAX_TRANSFER_SIZE;
  boolean expl_fb_ep = FALSE;
  uint8 fb_ep_attr = 0;
  uint8 fb_ep_num = 0;
  uint8 fb_bm1 = 0;
  uint8 fb_size = 0;
  usb_audio_stream_t* stream = (usb_audio_stream_t* )data;

  USB_ASSERT(stream);

  switch(stream->ifc_id)
  {
    case USB_IFC_ID_AUDIO_STREAMING_MIC:
    {
      ep_num = ++(*ep_in_num);
      ep_mask = USB_EP_ADDR_IN;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;
    }
    break;

    case USB_IFC_ID_AUDIO_STREAMING_SPEAKER:
    {
      ep_num = ++(*ep_out_num);
      ep_mask = USB_EP_ADDR_OUT;
      ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_ASYNC;

#ifdef USB_AUDIO_EXPL_ASYNC_FEEDBACK
      // Explicit ASYNC feedback endpoint
      expl_fb_ep = TRUE;
      fb_ep_num  = ++(*ep_in_num);
      fb_ep_num |= USB_EP_ADDR_IN;
      fb_ep_attr = USB_EP_ATTR_ISOCH | USB_EP_ATTR_SYNC_NONE | USB_EP_ATTR_USAGE_FEEDBACK;
      fb_size = (stream->speed == USB_FULL_SPEED) ? USB_AUDIO_FB_FREQ_SIZE_FS : USB_AUDIO_FB_FREQ_SIZE_HS;
#endif
    }
    break;

    default:
      USB_ERR_FATAL("Unknown stream type", stream->ifc_id, 0, 0);
  }


  // Allocate default interface alt_set(0).
  n_ep = 0;
  alt_set = 0;
  ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
    USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, 
    UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);
  ifc->id = stream->ifc_id;
  ifc->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;

  fb_bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(UAC30_FEEDBACK_EP_INTERVAL_US, stream->usb_frame_us);

  // Allocate alt_set(n)
  for(i=0; i < stream->slot_arr_size; i++)
  {
    slot_size = stream->slot_arr[i].slot_size;
    bit_res = stream->slot_arr[i].bit_res;
    bm1 = usb_fn_fd_audio()->usb_audio_get_bm1_from_us(stream->slot_arr[i].bint_us, stream->usb_frame_us);

    // Special Case : Burst Mode
    // In case data endpoint has higher bm1 use that for feedback endpoint.
    // Preserve saving realized through LPM by using higher service interval.
    if(bm1 > fb_bm1)
    {
      fb_bm1 = bm1;
    }

    alt_set = i+1;
    n_ep = expl_fb_ep ? 2 : 1;
    ifc_itr = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
      USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_STREAMING, 
      UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);
    INSERT_TAIL(usb_dcd_dsc_interface, ifc, ifc_itr);
    ifc_itr->setup = usb_fn_fd_audio()->usb_audio_stream_set_ifc;
    ifc_itr->id = stream->ifc_id;
    ifc_itr->cs_dsc = (*dsc);
    ifc_itr->cs_dsc_size = usb_fn_uac3()->uac30_alloc_as_ifc_desc(dsc, len, dsc_size, stream, slot_size, 
      bit_res, bm1, &max_packet_size);

    ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, ep_num, ep_mask, ep_attr, (bm1+1), 
      max_packet_size);
    INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, ep_itr);
    ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_session;
    ep_itr->ifc = ifc_itr;
    ep_itr->cs_dsc = (*dsc);
    ep_itr->cs_dsc_size = usb_fn_uac3()->uac30_alloc_as_cs_ep_desc(dsc, len, dsc_size);

    // Allocate explicit ASYNC feedback endpoint descriptor
    if (expl_fb_ep)
    {
      fb_ep_itr = usb_fn_fd()->usb_fd_alloc_ep_desc(dsc, len, dsc_size, fb_ep_num, USB_EP_ADDR_IN, fb_ep_attr,
        (fb_bm1+1), fb_size);
      INSERT_TAIL(usb_dcd_dsc_endpoint, ifc_itr->endpoints, fb_ep_itr);
      fb_ep_itr->setup = usb_fn_fd_audio()->usb_audio_start_expl_fb;
      fb_ep_itr->ifc = ifc_itr;
    }
  }

  return ifc;
}

void uac30_alloc_ac_pd_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_pd_t* apd)
{
  uac3_ac_pd_desc_t* pd = (uac3_ac_pd_desc_t *) (*dsc);
  (*len) += sizeof(uac3_ac_pd_desc_t);
  USB_ASSERT((*len) < dsc_size);
  pd->bLength             = sizeof(uac3_ac_pd_desc_t); // 13 bytes
  pd->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;
  pd->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_POWER_DOMAIN;
  pd->bPowerDomainID      = apd->id;
  pd->waRecoveryTime1     = UAC30_D1_TO_D0_RECOVERY_TIME_MS * (1000 / 50);  // Time to recover from D1 to D0. Expressed in terms of 50us.
  pd->waRecoveryTime2     = UAC30_D2_TO_D0_RECOVERY_TIME_MS * (1000 / 50);  // Time to recover from D2 to D0. Expressed in terms of 50us.
  pd->bNrEntities         = apd->n_entity;      // Always 2 (1 input and 1 output terminal)
  pd->baEntryID1          = apd->entity_id[0];  // ID of input terminal
  pd->baEntryID2          = apd->entity_id[1];  // ID of output terminal
  pd->wPDomainDescrStr    = 0x0000;
  (*dsc) += sizeof(uac3_ac_pd_desc_t);
}

void uac30_alloc_ac_ot_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_ot_t* aot,
  usb_audio_profile_t audio_profile)
{
  uac3_ac_ot_desc_t* ot = (uac3_ac_ot_desc_t*) (*dsc);
  (*len) += sizeof(uac3_ac_ot_desc_t);
  USB_ASSERT((*len) < dsc_size);
  ot->bLength             = sizeof(uac3_ac_ot_desc_t);    // 12 bytes
  ot->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  ot->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_OT; // OUTPUT_TERMINAL           
  ot->bTerminalID         = aot->id;
  ot->wTerminalType       = USB_AUDIO_TERM_TYPE_STREAMING;
  ot->bAssocTerminal      = 0x0;
  ot->bSourceID           = aot->source_id;
  ot->bCSourceID          = aot->clock_id;
  ot->bmControls          = 0x0;  
  ot->wExTerminalDescrID  = 0x0;
  ot->wConnectorsDescrID  = 0x0;
  ot->wTerminalDescrStr   = 0x0;

  if(aot->term_type == AUDIO_TERMINAL_SPEAKER)
  {
    ot->wTerminalType = usb_fn_fd_audio()->usb_audio_get_ot_type(audio_profile);
  }

  (*dsc) += sizeof(uac3_ac_ot_desc_t);
}

void uac30_alloc_ac_mu_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_mu_t* amu)
{
  uac3_ac_mu_desc_t* mu = (uac3_ac_mu_desc_t*) (*dsc);
  (*len) += sizeof(uac3_ac_mu_desc_t);
  USB_ASSERT((*len) < dsc_size);
  mu->bLength             = sizeof(uac3_ac_mu_desc_t);    // 16 bytes
  mu->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  mu->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_MU; // MIXER_UNIT
  mu->bUnitID             = amu->id;
  mu->bNrInPins           = amu->n_sources;
  mu->baSourceID1         = amu->source_id[0];
  mu->baSourceID2         = amu->source_id[1];
  mu->wClusterDescrID     = amu->n_op_ch;
  mu->bmMixerControls     = 0x00; 
  mu->bmControls          = 0x00;
  mu->wMixerDescrStr      = 0x00;  
  (*dsc) += sizeof(uac3_ac_mu_desc_t);
}

void uac30_alloc_ac_fu_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_fu_t* afu)
{
  uint8* ac_dsc = (*dsc);
  uac3_ac_fu_desc_t* fu = (uac3_ac_fu_desc_t*) ac_dsc;
  uint8 i;
  uint8 bLength = sizeof(uac3_ac_fu_desc_t) + (afu->n_ch * sizeof(uint32)) + 1; // 9 bytes + (4 * n_ch) + 1 (iFeature)

  (*len) += bLength;
  USB_ASSERT((*len) < dsc_size);
  fu->bLength             = bLength;   
  fu->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  fu->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_FU; // FEATURE_UNIT
  fu->bUnitID             = afu->id;
  fu->bSourceID           = afu->source_id;
  fu->bmaControls0        = 0;
  ac_dsc += sizeof(uac3_ac_fu_desc_t);

  // Master channel contols
  if(afu->controls & AUDIO_CTRL_FU_MUTE)
  {
    fu->bmaControls0 |= UAC30_FU_CONTROL_MUTE;
  }

  if(afu->controls & AUDIO_CTRL_FU_VOLUME)
  {
    fu->bmaControls0 |= UAC30_FU_CONTROL_VOLUME;
  }

  // Populate controls for logical channels.
  // Advertise same controls as master channel on logical channels.
  // bmaControls(n)
  for(i=0; i < afu->n_ch; i++)
  {
    // compiler cannot resolve unaligned word writes.
    ac_dsc[0] = (fu->bmaControls0 & 0xFF);
    ac_dsc[1] = ((fu->bmaControls0 & 0xFF00) >> 8);
    ac_dsc[2] = ((fu->bmaControls0 & 0xFF0000) >> 16);
    ac_dsc[3] = ((fu->bmaControls0 & 0xFF000000) >> 24);
    ac_dsc += sizeof(uint32);
  }

  // Assign uint8 wFeatureDescrStr
  *((uint16*) ac_dsc) = 0x0;
  ac_dsc += sizeof(uint16);
  (*dsc) = ac_dsc;
}

void uac30_alloc_ac_cl_desc(uint8** dsc, uint16* len, uint16 dsc_size, uint8 cl_id, 
  uint8 n_ch)
{
  uac3_ac_cl_header_desc_t* cl_header = (uac3_ac_cl_header_desc_t*)(*dsc);
  uac3_ac_cl_seg_inf_desc_t* cl_inf;
  uint8 i;
  
  (*len) += sizeof(uac3_ac_cl_header_desc_t);
  USB_ASSERT((*len) < dsc_size);
  cl_header->wLength            = sizeof(uac3_ac_cl_header_desc_t);
  cl_header->bDescriptorType    = USB_AUDIO_CS_CLUSTER_DESC_TYPE;
  cl_header->bDescriptorSubType = USB_AUDIO_CS_DESC_SUBTYPE_UNDEF;
  cl_header->wDescriptorID      = cl_id;
  cl_header->bNrChannels        = n_ch;
  (*dsc) += sizeof(uac3_ac_cl_header_desc_t);

  for(i = 0; i < n_ch; i++)
  {
    cl_inf = (uac3_ac_cl_seg_inf_desc_t*)(*dsc);
    (*len) += sizeof(uac3_ac_cl_seg_inf_desc_t);
    cl_header->wLength += sizeof(uac3_ac_cl_seg_inf_desc_t);
    USB_ASSERT((*len) < dsc_size);
    cl_inf->wLength         = sizeof(uac3_ac_cl_seg_inf_desc_t);
    cl_inf->bSegmentType    = UAC30_CLUSTER_DESCR_SEG_CH_INF;
    cl_inf->bChPurpose      = 0x00;
    cl_inf->bChRelationship = (n_ch + i); // Mono = 1, Left = 2, Right = 3
    cl_inf->bChGroupID      = 0x00;
    cl_inf->wLengthEndSeg   = 0x03;
    cl_inf->bSegmentTypeEnd = UAC30_CLUSTER_DESCR_SEG_END;
    (*dsc) += sizeof(uac3_ac_cl_seg_inf_desc_t);
  }
}

void uac30_alloc_ac_conn_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  audio_conn_t* aconn)
{
  uac3_ac_conn_desc_t* conn = (uac3_ac_conn_desc_t *)(*dsc);
  (*len) += sizeof(uac3_ac_conn_desc_t);
  USB_ASSERT((*len) < dsc_size);
  conn->wLength             = sizeof(uac3_ac_conn_desc_t);
  conn->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;
  conn->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_CONN;
  conn->wDescriptorID       = aconn->id;
  conn->bNrConnectors       = 0x1;
  conn->baConID             = aconn->conn_id;
  conn->waClusterDescrID    = aconn->n_ch;
  conn->baConType           = UAC30_CONN_TYPE_3P5MM;
  conn->bmaConAttributes    = (UAC30_CONN_ATTR_GENDER_FEMALE << UAC30_CONN_ATTR_GENDER_POS) |
                              (UAC30_CONN_ATTR_INSERT_YES << UAC30_CONN_ATTR_INSERT_POS);
  conn->waConDescrStr       = 0x00;
  conn->daConColor          = UAC30_CONN_COLOR_UNSPECIFIED;
  (*dsc) += sizeof(uac3_ac_conn_desc_t);
}

void uac30_alloc_ac_it_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_it_t* ait)
{
  uac3_ac_it_desc_t* it = (uac3_ac_it_desc_t*)(*dsc);

  (*len) += sizeof(uac3_ac_it_desc_t);
  USB_ASSERT((*len) < dsc_size);
  it->bLength             = sizeof(uac3_ac_it_desc_t);    // 17 bytes
  it->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;       // CS_INTERFACE
  it->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_IT; // INPUT_TERMINAL           
  it->bTerminalID         = ait->id;
  it->wTerminalType       = USB_AUDIO_TERM_TYPE_STREAMING;
  it->bAssocTerminal      = 0x00;
  it->bCSourceID          = ait->clock_id;
  it->bmControls          = 0x00;
  it->wClusterDescrID     = UAC30_CLUSTER_DESCR_MONO;
  it->wExTerminalDescrID  = 0x00;
  it->wConnectorsDescrID  = 0x00;
  it->wTermDescrStr       = 0x00;

  if(ait->term_type == AUDIO_TERMINAL_MIC)
  {
    it->wTerminalType = USB_AUDIO_TERM_TYPE_IT_MIC;
  }

  if(ait->n_ch == 2) // stereo
  {
    it->wClusterDescrID = UAC30_CLUSTER_DESCR_STEREO;
  }
  
  (*dsc) += sizeof(uac3_ac_it_desc_t);
}

void uac30_alloc_ac_csel_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_ifc_id ifc_id, uint8 source_id, uint8 term_id)
{
  uac3_ac_csel_desc_t* csel = (uac3_ac_csel_desc_t*)(*dsc);
  (*len) += sizeof(uac3_ac_csel_desc_t);
  USB_ASSERT((*len) < dsc_size);
  csel->bLength             = sizeof(uac3_ac_csel_desc_t);
  csel->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;         // CS_INTERFACE
  csel->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_CSRC; // CLOCK_SOURCE
  csel->bClockID            = term_id;  // Terminal ID of clock
  csel->bNrPins             = 0x1;      // 0x1 - hard coded
  csel->baCSourceID         = source_id;
  csel->bmControls          = 0x0;
  csel->wCSelectorDescrStr  = 0x0;
  (*dsc) += sizeof(uac3_ac_csel_desc_t);
}

void uac30_alloc_ac_csrc_desc(uint8** dsc, uint16* len, uint16 dsc_size, audio_cs_t* acs)
{
  uac3_ac_csrc_desc_t* csrc = (uac3_ac_csrc_desc_t*)(*dsc);
  (*len) += sizeof(uac3_ac_csrc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  csrc->bLength             = sizeof(uac3_ac_csrc_desc_t);    // 8 bytes
  csrc->bDescriptorType     = USB_AUDIO_CS_DESC_TYPE;         // CS_INTERFACE
  csrc->bDescriptorSubType  = USB_AUDIO_CS_DESC_SUBTYPE_CSRC; // CLOCK_SOURCE
  csrc->bClockID            = acs->id;                        // Terminal ID of clock
  csrc->bmAttributes        = (UAC30_CS_ATTR_CT_INTERNAL << UAC30_CS_ATTR_CT_POS) | 
                              (UAC30_CS_ATTR_ST_ASYNC << UAC30_CS_ATTR_ST_POS);
  csrc->bmControls          = 0x00;
  csrc->bReferenceTerminal  = 0x00;
  csrc->wClockSourceStr     = 0x00;

  // TODO: BADD mandates clock frequency control to be read only
  if (acs->controls & AUDIO_CTRL_CS_FREQ)
  {
    csrc->bmControls |= (UAC30_CONTROL_HOST_PGM << UAC30_CS_BMC_CLK_FREQ_POS);
  }

  if (acs->controls & AUDIO_CTRL_CS_VALID)
  {
    csrc->bmControls |= (UAC30_CONTROL_READ_ONLY << UAC30_CS_BMC_CLK_VALD_POS);
  }

  (*dsc) += sizeof(uac3_ac_csrc_desc_t);
}

void uac30_alloc_ac_header_desc(uint8** dsc, uint16* len, uint16 dsc_size, uint8 n_as, 
  uint8 ifc_idx, uint8 fn_category)
{
  uac3_cs_ac_ifc_header_t* ac_header = (uac3_cs_ac_ifc_header_t *) (*dsc);
  (*len) += sizeof(uac3_cs_ac_ifc_header_t);
  USB_ASSERT((*len) < dsc_size);
  ac_header->bLength            = sizeof(uac3_cs_ac_ifc_header_t);  // 9 bytes
  ac_header->bDescriptorType    = USB_AUDIO_CS_DESC_TYPE;           // CS_INTERFACE
  ac_header->bDescriptorSubType = USB_AUDIO_CS_DESC_SUBTYPE_HEADER; // Header            
  ac_header->bCategory          = fn_category;    
  ac_header->wTotalLength       = sizeof(uac3_cs_ac_ifc_header_t);  // Update at end
  ac_header->bmControls         = 0x00;                             // None.
  (*dsc) += sizeof(uac3_cs_ac_ifc_header_t);
}


uint16 uac30_alloc_ac_cs_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  usb_audio_ctx_t* audio_ctx, uint8 ifc_num, uint8 fn_category)
{
  uint8 i;
  uac3_cs_ac_ifc_header_t* ac_header;
  uint32 uac_offset = (*len);

  // Allocate class speficic header
  ac_header = (uac3_cs_ac_ifc_header_t*) (*dsc);
  usb_fn_uac3()->uac30_alloc_ac_header_desc(dsc, len, dsc_size, audio_ctx->n_ifc, ifc_num, fn_category);

  // Get number of audio streams registered with AudioControl interface.
  // TODO: add mono and stereo cluster descriptors
  
  for(i = 0; i < audio_ctx->n_nodes; i++)
  {
    audio_node_t* node = &audio_ctx->topology[i];
    switch(node->val.type)
    {
      case AUDIO_CLOCK_SOURCE:
      {
        usb_fn_uac3()->uac30_alloc_ac_csrc_desc(dsc, len, dsc_size, (audio_cs_t*) node);
      }
      break;

      case AUDIO_INPUT_TERMINAL:
      {
        usb_fn_uac3()->uac30_alloc_ac_it_desc(dsc, len, dsc_size, (audio_it_t*) node);
      }
      break;

      case AUDIO_FEATURE_UNIT:
      {
        usb_fn_uac3()->uac30_alloc_ac_fu_desc(dsc, len, dsc_size, (audio_fu_t*) node);
      }
      break;

      case AUDIO_MIXER_UNIT:
      {
        usb_fn_uac3()->uac30_alloc_ac_mu_desc(dsc, len, dsc_size, (audio_mu_t*) node);
      }
      break;

      case AUDIO_OUTPUT_TERMINAL:
      {
        usb_fn_uac3()->uac30_alloc_ac_ot_desc(dsc, len, dsc_size, (audio_ot_t*)node, audio_ctx->profile);
      }
      break;

      case AUDIO_CONNECTOR:
      {
        usb_fn_uac3()->uac30_alloc_ac_conn_desc(dsc, len, dsc_size, (audio_conn_t*) node);
      }
      break;

      case AUDIO_POWER_DOMAIN:
      {
        usb_fn_uac3()->uac30_alloc_ac_pd_desc(dsc, len, dsc_size, (audio_pd_t*) node);
      }
      break;

      default:
        USB_ULOG_1(DBG_E_QLOG, "unknwon node type %d", node->val.type);
        USB_LOG_ERR_1(log_uac30_alloc_ac_cs_desc__unknown_node_D, (uint32)node->val.type);
    }
  }

  ac_header->wTotalLength = (*len) - uac_offset;
  return ((*len) - uac_offset);
}
#endif

void uac30_alloc_ac_ifc_asoc_desc(uint8** dsc, uint16* len, uint16 dsc_size, 
  uint8 ifc_num, uint8 n_ifc, uint8 profile_id)
{
  uac_std_ifc_asoc_desc_t* ifc_asoc = (uac_std_ifc_asoc_desc_t*) (*dsc);
  (*len) += sizeof(uac_std_ifc_asoc_desc_t);
  USB_ASSERT((*len) < dsc_size);
  ifc_asoc->bLength           = sizeof(uac_std_ifc_asoc_desc_t); // 8 bytes
  ifc_asoc->bDescriptorType   = USB_AUDIO_STD_IFC_ASOC_DESC_TYPE; // CS_INTERFACE
  ifc_asoc->bFirstInterface   = ifc_num;
  ifc_asoc->bInterfaceCount   = n_ifc;
  ifc_asoc->bFunctionClass    = USB_INTERFACE_CLASS_AUDIO;
  ifc_asoc->bFunctionSubClass = profile_id;
  ifc_asoc->bFunctionProtocol = UAC30_FN_PROTOCOL_VERSION_03_00;
  ifc_asoc->iFunction         = 0x00;
  (*dsc) += sizeof(uac_std_ifc_asoc_desc_t);
}


uint8 uac30_get_fn_category(usb_audio_profile_t profile)
{
  uint8 category;
  switch(profile)
  {
    case USB_AUDIO_HEADSET:
    {
      category = USB_AUDIO_FN_CATEGORY_HEADSET;
    }
    break;
    
    case USB_AUDIO_HEADSET_ADAPTOR:
    {
      category = USB_AUDIO_FN_CATEGORY_HEADSET_ADAPTOR;
    }
    break;

    case USB_AUDIO_SPEAKERPHONE:
    {
      category = USB_AUDIO_FN_CATEGORY_SPEAKER_PHONE;
    }
    break;

    case USB_AUDIO_HEADPHONE:
    {
      category = USB_AUDIO_FN_CATEGORY_HEADPHONE;
    }
    break;
    
    case USB_AUDIO_SPEAKER:
    {
      category = USB_AUDIO_FN_CATEGORY_GENERIC_SPEAKER;
    }
    break;

    case USB_AUDIO_MICROPHONE:
    {
      category = USB_AUDIO_FN_CATEGORY_MICROPHONE;
    }
    break;

    default:
      category = USB_AUDIO_FN_CATEGORY_OTHER;
  }
  return category;
}

uint8 badd3_get_profile_id(usb_audio_profile_t profile)
{
  uint8 profile_id;
  switch(profile)
  {
    case USB_AUDIO_HEADSET:
    {
      profile_id = UAC30_PROFILE_ID_HEADSET;
    }
    break;
    
    case USB_AUDIO_HEADSET_ADAPTOR:
    {
      profile_id = UAC30_PROFILE_ID_HEADSET_ADAPTER;
    }
    break;

    case USB_AUDIO_SPEAKERPHONE:
    {
      profile_id = UAC30_PROFILE_ID_SPEAKERPHONE;
    }
    break;

    case USB_AUDIO_HEADPHONE:
    {
      profile_id = UAC30_PROFILE_ID_HEADPHONE;
    }
    break;
    
    case USB_AUDIO_SPEAKER:
    {
      profile_id = UAC30_PROFILE_ID_SPEAKER;
    }
    break;

    case USB_AUDIO_MICROPHONE:
    {
      profile_id = UAC30_PROFILE_ID_MICROPHONE;
    }
    break;

    default:
      profile_id = UAC30_PROFILE_ID_GENERIC_IO;
  }
  return profile_id;
}

usb_dcd_dsc_interface_t* badd3_alloc_ac_desc(uint8 ** dsc, uint16 * len, 
  uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 alt_set = 0;
  uint8 n_ep = 0;
  usb_audio_ctx_t* audio_ctx = (usb_audio_ctx_t*) data;
  uint8 profile_id; // BADD3 profile

  USB_ASSERT(audio_ctx);

  profile_id = usb_fn_uac3()->badd3_get_profile_id(audio_ctx->profile);

  // Allocate interface association descriptor for AudioControl class collection
  usb_fn_uac3()->uac30_alloc_ac_ifc_asoc_desc(dsc, len, dsc_size, ifc_num, audio_ctx->n_ifc+1, profile_id);

  audio_ctx->ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
    USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_CONTROL,
    UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);

  audio_ctx->ifc->id = audio_ctx->id;
  audio_ctx->ifc->cs_dsc = NULL;
  audio_ctx->ifc->cs_dsc_size = 0;
  return audio_ctx->ifc;
}
#ifdef USB_ENABLE_UAC30_FLAG
usb_dcd_dsc_interface_t* uac30_alloc_ac_desc(uint8 ** dsc, uint16 * len, 
  uint16 dsc_size, void* data, uint8 ifc_num, uint8* ep_in_num, uint8* ep_out_num)
{
  uint8 alt_set = 0;
  uint8 n_ep = 0;
  usb_dcd_dsc_interface_t* ifc;
  usb_audio_ctx_t* audio_ctx = (usb_audio_ctx_t*) data;
  uint8 fn_cat; // function category

  USB_ASSERT(audio_ctx);

  // Allocate interface association descriptor for AudioControl class collection
  usb_fn_uac3()->uac30_alloc_ac_ifc_asoc_desc(dsc, len, dsc_size, ifc_num, audio_ctx->n_ifc+1, 
    UAC30_PROFILE_ID_FULL_ADC_3_0);

  fn_cat = usb_fn_uac3()->uac30_get_fn_category(audio_ctx->profile);

  ifc = usb_fn_fd()->usb_fd_alloc_ifc_desc(dsc, len, dsc_size, ifc_num, alt_set, n_ep, 
    USB_INTERFACE_CLASS_AUDIO, USB_INTERFACE_AUDIO_SUBCLASS_CONTROL, 
    UAC30_IFC_PROTOCOL_VERSION_03_00, USB_INTERFACE_STR_INDEX_NONE);

  ifc->id = audio_ctx->id;
  ifc->cs_dsc = (*dsc);
  ifc->cs_dsc_size = usb_fn_uac3()->uac30_alloc_ac_cs_desc(dsc, len, dsc_size, audio_ctx, ifc_num, fn_cat);
  return ifc;
}
#endif

/*----------------------------------------------------------------------------
 * Function table definitions - UAC3.0 layer
 * -------------------------------------------------------------------------*/

usb_fn_tbl_uac3_t fn_tbl_uac3 = 
{
  uac30_ac_handle_get_req,
  uac30_ac_handle_set_req,
  uac30_as_handle_get_req,
  uac30_as_handle_set_req,
  badd3_get_bps,
  badd3_alloc_as_desc,
#ifdef USB_ENABLE_UAC30_FLAG
  uac30_get_bps,
  uac30_alloc_as_cs_ep_desc,
  uac30_alloc_as_ifc_desc,
  uac30_alloc_as_desc,
  uac30_alloc_ac_pd_desc,
  uac30_alloc_ac_ot_desc,
  uac30_alloc_ac_mu_desc,
  uac30_alloc_ac_fu_desc,
  uac30_alloc_ac_cl_desc,
  uac30_alloc_ac_conn_desc,
  uac30_alloc_ac_it_desc,
  uac30_alloc_ac_csel_desc,
  uac30_alloc_ac_csrc_desc,
  uac30_alloc_ac_header_desc,
  uac30_alloc_ac_cs_desc,
  uac30_alloc_ac_desc,
#endif
  uac30_alloc_ac_ifc_asoc_desc,
  uac30_get_fn_category,
  badd3_get_profile_id,
  badd3_alloc_ac_desc,
};

